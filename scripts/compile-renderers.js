/**
 * Medic Forms: A flexible data collection system
 *
 * Copyright 2013-2014 David Brown <david@medicmobile.org>
 * Copyright 2013-2014 Medic Mobile, Inc. <hello@medicmobile.org>
 * All rights reserved.
 *
 * Medic Forms is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, version three.
 *
 * You should have received a copy of version three of the GNU General
 * Public License along with this file. If you did not, you can download a
 * copy from http://www.gnu.org/licenses/.
 *
 * Medic Forms is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL DAVID BROWN OR MEDIC MOBILE BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

/**
 * This script is executed as one of the npm postinstall hooks.
 */

var fs = require('fs'),
    path = require('path'),
    _ = require('underscore'),
    moment = require('moment'),
    util = require('./include/util'),
    base_path = 'lib/renderers';


/**
 * @name main:
 */
var main = function (_argc, _argv) {

  var output_path = base_path + '/_compiled.js';

  /* Build file */
  var data = [];
  _write_header(data);
  _write_helpers(data);
  _write_partials(data);
  _write_modules(data);

  /* Write output */
  fs.writeFileSync(output_path, data.join('\n'));

  /* Success */
  process.stderr.write(
    'File `' + output_path + '` generated successfully.\n'
  );

  return 0;
};

/**
 * @name _write_header:
 */
function _write_header (_data) {
  _data.push(
    '/* Generated by compile-renderers.js on '
      + moment().local().format('YYYY-MM-DD [at] hh:mma') + ' */\n'
  );
  _data.push("var handlebars = require('handlebars');\n");
}

/**
 * @name _write_helpers:
 */
function _write_helpers (_data) {
  _data.push('/* Extensions */');
  var path = base_path + '/helpers';
  var files = fs.readdirSync(path);
  _.each(files, function (_element) {
    if (_element.match(/.*\.js/)) {
      _data.push("require('./helpers/" + _element + "');");
    }
  });
  _data.push('');
}

/**
 * @name _write_partials:
 */
function _write_partials (_data) {
  _data.push('/* Handlebars partials */');
  var path = base_path + '/partials';
  var files = fs.readdirSync(path);
  _.each(files, function (_element) {
    if (_element.match(/.*\.html/)) {
      var name = _element.split('.')[0];
      var contents = _read_and_escape(path + '/' + _element);
      _data.push("handlebars.registerPartial('" + name +
        "', '" + contents + "');");
    }
  });
  _data.push('');
}

/**
 * @name _write_modules:
 */
function _write_modules (_data) {
  /* Append all renderers */
  var modules = [];
  _read_directory(base_path + '/standard', modules);
  var required = _.map(modules, function(module) {
    return '  require(\'' + module.module + '\').init(' + 
        JSON.stringify(module.attachments) + ')';
  });
  _data.push('/* Render modules */');
  _data.push('exports.modules = [');
  _data.push(required.join(',\n'));
  _data.push('];');
}

/**
 * @name _create_module:
 */
function _create_module(fpath) {
  var renderer = JSON.parse(fs.readFileSync(fpath + '/renderer.json'));
  var result = {
    module: '../../' + fpath + '/' + renderer.module
  }
  if (renderer.attachments) {
    result.attachments = {};
    _.each(_.pairs(renderer.attachments), function(entry) {
      result.attachments[entry[0]] = _read_and_escape(fpath + '/' + entry[1]);
    });
  }
  return result;
}

/**
 * @name _read_directory:
 */
function _read_directory (_path, _modules) {

  var files = fs.readdirSync(_path);

  _.each(files, function (_element) {
    
    /* Skip dot-prefixed files/directories */
    if (_element.match(/^\./)) {
      return;
    }

    var fpath = path.join(_path, _element);
    var fstats = fs.statSync(fpath);
    
    if (fstats.isDirectory()) {
      if (fs.existsSync(fpath + '/renderer.json')) {
        _modules.push(_create_module(fpath));
      } else {
        _read_directory(fpath, _modules);
      }
    }
  });
}

function _read_and_escape(_path) {
  return util.escape_json_string(fs.readFileSync(_path));
}

/* Entry point:
 *   Start `main` and exit with the returned status. */

process.exit(
  main(process.argv.length, process.argv)
);

