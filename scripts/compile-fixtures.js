/**
 * this function is executed as the postinstall hook.
 * It puts all the test fixtures data into tests/fixtures.js
 * and export the fixtures object.
 * @type {[type]}
 */
var fs = require('fs'),
    path = require('path'),
    _ = require('underscore'),
    moment = require('moment');


/**
 * @name main:
 */
var main = function (_argc, _argv) {

  var output_path = "tests/fixtures/compiled.js";

  /* Build file */
  var data = [
    "/* Generated by compile-fixtures.js on "
      + moment().local().format('YYYY-MM-DD [at] hh:mma') + ' */',
    "var fs = require('fs');", '',
    '/* Alias */',
    "var tests = exports;", '',
    '/* Top-level fixtures object */',
    "tests.fixtures = {};", ''
  ];

  /* Append all test fixtures */
  _read_directory("tests/fixtures", data);

  /* Append JSON schema */
  data = data.concat([
    "tests.schema = JSON.parse('" +
      _escape_string(fs.readFileSync("schemas/base.json")) + "');"
  ]);

  /* Write output */
  fs.writeFileSync(output_path, data.join("\n"));

  /* Success */
  process.stderr.write(output_path + " generated successfully.\n");

  return 0;
};


/**
 * conver the path to objects
 * tests/fixtures/forms --> tests.fixtures.forms = {};
 * tests/fixtures/forms/invalid.json --> tests.fixtures.forms.invalid
 * @param  {[type]} path [description]
 * @return {[type]}      [description]
 */
function _object_name_from_path(_path) {

  var i, name = _path.split("/").join(".");

  if ((i = name.indexOf(".json")) > 0) {
    name = name.substring(0, i);
  }
  return name.replace(/[^A-Za-z0-9\_\.]/g, "_");
}


/**
 * @name _escape_string:
 *   Escape the JSON-containing string `_string` in a way that
 *   allows it to be contained within a single-quoted string.
 *   Reduce whitespace wherever possible.
 */
function _escape_string (_string) {

  return (
    _string.toString().replace(/\\/g, "\\\\")
      .replace(/'/g, "\\'").replace(/[\n\t\s]+/g, ' ')
  );
};


/**
 * @name _get_line_data:
 */
function _get_line_data (fpath, isFile) {

  if (isFile) {
    return (
      "/* File: " + fpath + " */ \n" +
        _object_name_from_path(fpath) + " = JSON.parse('" +
          _escape_string(fs.readFileSync(fpath)) + "');\n"
    );
  } else {
    return (
      "/* Directory: " + fpath + " */ \n" +
        _object_name_from_path(fpath) + " = {};\n"
    );
  }
}


/**
 * @name _read_directory:
 */
function _read_directory (_path, _data) {

  var files = fs.readdirSync(_path);

  _.each(files, function (_element, _index) {

    var fpath = path.join(_path, _element);
    var fstats = fs.statSync(fpath);

    /* Skip dot-prefixed files/directories */
    if (_element.match(/^\./)) {
      return;
    }
    
    /* Process files */
    if (fstats.isDirectory()) {

      /* Emit directory object */
      _data.push(_get_line_data(fpath, false));

      /* Recur in to directory */
      _read_directory(fpath, _data);

    } else if (fstats.isFile()) {

      /* Only process .json files */
      if (_element.match(/\.json$/)) {
        _data.push(_get_line_data(fpath, true));
      }
    }
  });
}


/* Entry point:
 *   Start `main` and exit with the returned status. */

process.exit(
  main(process.argv.length, process.argv)
);

