
var fs = require('fs'),
    _ = require('underscore'),
    util = require('../../lib/util'),
    deep_equal = require('deep-equal');


/**
 * @name is_recursive_subset:
 *   Return true if the variable `_subset` is a subset of `_superset`.
 *   These arguments are evaluated recursively; the algorithm will
 *   descend in to arrays and ordinary objects until none remain.
 *   Returns true if each property in the tree `_subset` exists in
 *   `_superset` and has an identical value as determined by a
 *   `deep_equal` comparison; false otherwise.
 */
exports.is_recursive_subset = function (_subset, _superset) {

  /* Object case */
  if (util.is_plain_object(_subset)) {
    if (!util.is_plain_object(_superset)) {
      return false;
    }
    for (var k in _subset) {
      if (!exports.is_recursive_subset(_superset[k], _subset[k])) {
        return false;
      }
    }
  /* Array case */
  } else if (_.isArray(_subset)) {
    if (!_.isArray(_superset)) {
      return false;
    }
    for (var i = 0, len = _subset.length; i < len; ++i) {
      if (!exports.is_recursive_subset(_superset[i], _subset[i])) {
        return false;
      }
    }
  /* Other cases */
  } else if (!_.isUndefined(_subset)) {
    return deep_equal(_superset, _subset);
  }

  return true;
};


/**
 * @name make_tests
 *   Creates a list of tests for `nodeunit`, given an `_exports`
 *   object in which to create the tests, a `_name`a `_fixtures` object
 *   containing test fixtures, a `_test_fn` containing the test
 *   code to be executed, and a list of one or more parameters
 *   in `_test_args` to be provided as arguments to `_test_fn`.
 */
exports.make_tests = function (_name, _exports,
                               _fixtures, _test_fn, _test_args) {

  _.each(_fixtures, function (_fixture, _i) {

    var _test_name = _generate_test_name(_name, _fixture, _i);

    if (_fixture.values) {
      _.each(_fixture.values, function (_value, _j) {
        _export(_test_name + _generate_test_name_suffix(_fixture, _j), 
          _fixture, _exports, _test_fn, _test_args, _value);
      });
    } else {
      _export(_test_name, _fixture, _exports, _test_fn, _test_args);
    }
  });
};


/**
 * @name _export:
 *   Insert a test case beneath the `exports` namespace, which
 *   effectively adds the test case to nodeunit's list of tests.
 */
var _export = function (_name, _fixture, _exports,
                        _test_fn, _test_args, _value) {

  _exports[_name] = function (_test) {
    _test_fn.apply(
      this, [ _test, _fixture, _value ].concat(_test_args)
    );
  };
};


/**
 * @name _generate_test_name:
 *   Generate a printable description for the test fixture `_fixture`.
 *   Use `_name` as a test category name and `_index` as the ordinal
 *   position of the test fixture.
 */
var _generate_test_name = function (_name, _fixture, _index) {

  return (
    _name + ': ' + (
      _fixture._name ?
        _fixture._name : 'Test fixture #' + (_index + 1)
    )
  );
};


/**
 * @name _generate_test_name_suffix:
 *   Return a suffix (or, if not applicable, the empty string) for
 *   the test name generated by `_generate_test_name`. If the fixture
 *   contains multiple testable entities, the `_ordinal` argument
 *   (optional) should contain the ordinal position of the entity
 *   being tested.
 */
var _generate_test_name_suffix = function (_fixture, _ordinal) {

  if (_fixture.values && _fixture.values.length > 1) {
    return ' at ' + _ordinal;
  }

  return '';
}
